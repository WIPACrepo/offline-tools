#!/usr/bin/env python

"""
Gather information about recent runs from live database and migrate it to
the prodcution databases (i3filter on dbs4). Modifies tables grl_snapshot_info
and run_info_summary on dbs4
"""

import os
import re
import SQLClient_i3live as live
import SQLClient_dbs4 as dbs4
import SQLClient_dbs2 as dbs2

from sys import exit
from libs.logger import get_logger
from libs.argparser import get_defaultparser
from libs.files import get_logdir, get_tmpdir
import libs.checks
from RunTools import RunTools
import libs.config

import sys

dbs4_ = dbs4.MySQL()
m_live = live.MySQL()
dbs2_ = dbs2.MySQL()

def send_check_notification(logger, dryrun, config, new_records, changed_records):
    sys.path.append(config.get('DEFAULT', 'ProductionToolsPath'))
    import SendNotification as SN

    SENDER = config.get('Notifications', 'eMailSender')
    RECEIVERS = libs.config.get_var_list('GetRunInfo', 'NotificationReceiver')
    DOMAIN = config.get('Notifications', 'eMailDomain')
    
    message = ""
    subject = " New snapshot available"
    messageBody = ""
    
    # only necessary for html emails
    mimeVersion="1.0"
    contentType="text/html"
    
    messageBody += """
        *** This is an automated message generated by the *** <br>
        ***        GetRunInfo system of L2 Processing     *** <br><br>
        
        A new snapshot is available!

        New Runs: %s
        Changed Runs: %s
        """ % (new_records, changed_records)
   
    logger.debug("Receivers: %s" % RECEIVERS)
 
    message = SN.CreateMsg(DOMAIN, SENDER, RECEIVERS, subject,messageBody,mimeVersion,contentType)
    
    if len(message) and not dryrun:
        SN.SendMsg(SENDER,RECEIVERS,message)

    
def main(config, logger,dryrun = False, check = False):
    if check:
        logger.info('Only in check mode. Just checking if an update is available.')

    # Get the current production version and snapshot info 
    # from the production database dbs4
    CurrentInfo = dbs4_.fetchall("""select max(snapshot_id) as maxSnapshotID,
                                    max(production_version) as maxProductionV,
                                    max(ss_ref) as max_ss_ref
                                    from i3filter.grl_snapshot_info""",UseDict=True)
    
    CurrentMaxSnapshot = int(CurrentInfo[0]['maxSnapshotID'])
    CurrentProductionVersion = int(CurrentInfo[0]['maxProductionV'])
    ss_ref = int(CurrentInfo[0]['max_ss_ref']) + 1
    logger.debug("Got current max production_version %i and ss_ref %i from grl_snapshot_info table" %(CurrentMaxSnapshot,CurrentProductionVersion)) 
    
    seasons = libs.config.get_seasons_info()
    current_season = config.getint('DEFAULT', 'Season')

    # First run of current season
    IC86_5_FirstRun = seasons[current_season]['first']  # 

    # If it is -1 (that means the season hasn't begun yet) replace it with a very high number
    # to enable processing the test runs
    if IC86_5_FirstRun == -1:
        IC86_5_FirstRun = 9999999

    # Dfeault last run. If no next season is defined, this value will be kept
    IC86_5_LastRun = 9999999

    # If a next season is defined, we need to exclude those test runs
    exclude_next_testruns = [-1]
 
    if current_season + 1 in seasons:
        if seasons[current_season + 1]['first'] > -1:
            # last run of the current season is the start run of the next season minus one
            IC86_5_LastRun = seasons[current_season + 1]['first'] - 1
            exclude_next_testruns = seasons[current_season + 1]['test']

    # get the newest data from the live db      
    livesql = """SELECT r.runNumber,r.tStart,r.tStop,
                    r.tStart_frac,r.tStop_frac,r.nEvents,r.rateHz,
                    l.snapshot_id,l.good_i3,l.good_it,l.reason_i3,l.reason_it,
                    l.good_tstart, l.good_tstart_frac, l.good_tstop,l.good_tstop_frac
                 FROM live.livedata_snapshotrun l
                 JOIN live.livedata_run r
                    ON l.run_id=r.id
                 WHERE (r.runNumber>=%s OR r.runNumber IN (%s))
                    AND r.runNumber<=%s
                    AND r.runNumber NOT IN (%s)
                 ORDER BY l.snapshot_id""" % (IC86_5_FirstRun,
                        ','.join([str(r) for r in seasons[current_season]['test']] + ['-1']),
                        IC86_5_LastRun,
                        ','.join(str(r) for r in exclude_next_testruns))
   
    logger.debug("SQL to get data from live: %s" % livesql)

    tmp_i3_ = m_live.fetchall(livesql, UseDict = True)
 
    if not len(tmp_i3_):
        logger.info("no results from i3Live DB for runs>=%s, snapshot_id>%s. no DB info. updated,exiting"%(IC86_5_FirstRun,CurrentMaxSnapshot))
        exit(0)
        
    # dict structure of live db data ensures only latest entry for every run is considered
    RunInfo_ = {}

    # Need to catch all run id/snapshot id combinations of all runs
    # That means that it needs to be aware of that one run can have several entries/snapshot ids
    Run_SSId = []

    for r_ in tmp_i3_:
        for k in r_.keys():
            if r_[k] is None : r_[k]="NULL"

        RunInfo_[r_['runNumber']] = r_

        # Add run id/snapshot id combination
        Run_SSId.append((r_['runNumber'], r_['snapshot_id']))
    
    RunNums_ = RunInfo_.keys()
    RunNums_.sort()
    
    Run_SSId_Str_ = ",".join(["'%s_%s'" % (r[0], r[1]) for r in Run_SSId])
    RunStr_ = ",".join([str(r) for r in RunNums_])

    # get all previous runs from dbs4 and check if entries in live are different
    tmpRecords_ = dbs4_.fetchall("""select run_id from i3filter.run_info_summary
                                    order by run_id""",UseDict=True)
    tRecords_ = [t_['run_id'] for t_ in tmpRecords_]
    NewRecords_ = list(set(RunNums_).difference(set(tRecords_)))
    NewRecords_.sort()
    
    oRecords_ = dbs4_.fetchall("""select run_id from i3filter.grl_snapshot_info
                             where concat(run_id,"_",snapshot_id) in (%s)
                             order by run_id"""%Run_SSId_Str_,UseDict=True)
    OldRecords_ = [o_['run_id'] for o_ in oRecords_]
    
    cRecords_ = dbs4_.fetchall("""select s.run_id
                             from i3filter.grl_snapshot_info r
                             join i3filter.run_info_summary s on s.run_id=r.run_id
                             where concat(r.run_id,"_",r.snapshot_id) not in (%s)
                             and s.run_id in (%s)
                             order by s.run_id"""%(Run_SSId_Str_,RunStr_),UseDict=True)
    
    if len(cRecords_):
        logger.info("""The following records have changed and will result in  an update to
                 the ProductionVersion %s""" %cRecords_.__repr__())

        if not check:
            logger.info("Continue porcessing with updates (Y/N)")
            continueProcessing = raw_input("Continue porcessing with updates (Y/N) : " )
    
            if continueProcessing.upper() != "Y":
                logger.info("halting processig due to user intervention ...")
                exit (0)
    
    ChangedRecords_ = [c_['run_id'] for c_ in cRecords_]
    if len(cRecords_):
        CurrentProductionVersion +=1
    
    if not len(NewRecords_) and not len(ChangedRecords_):
        logger.info("no records to be inserted/updated .. exiting")
        exit(0)

    if check:
        logger.info("New records available. This was only a check. Do nothing. Exit.")
        send_check_notification(logger, dryrun, config, NewRecords_, ChangedRecords_)
        exit(0)
    
    for r in RunNums_:
        if r in OldRecords_ : continue
        if r in NewRecords_:
            logger.info("entering new records for run = %s"%r)
            R = RunTools(r,logger=logger)
            RunTimes = R.GetRunTimes()
            InFiles = R.GetRunFiles(RunTimes['tStart'],'P')
            CheckFiles = R.FilesComplete(InFiles, RunTimes, get_tmpdir())
   
            #  fill new runs from live in run_info_summary 
            if not dryrun: dbs4_.execute( """insert into i3filter.run_info_summary
                        (run_id,tStart,tStop,tStart_frac,tStop_frac,nEvents,rateHz,FilesComplete)
                        values(%u,"%s","%s","%s","%s",%s,%s,%u) """ \
                        %(r,RunInfo_[r]['tStart'],RunInfo_[r]['tStop'],
                        RunInfo_[r]['tStart_frac'],RunInfo_[r]['tStop_frac'],
                        RunInfo_[r]['nEvents'],RunInfo_[r]['rateHz'],CheckFiles))
        
        reason_i3 = ""
        reason_i3 = re.sub(r'[",]','',",".join(RunInfo_[r]['reason_i3'][1:-1].split(",")))
        reason_it = "" 
        reason_it = re.sub(r'[",]','',",".join(RunInfo_[r]['reason_it'][1:-1].split(",")))
    
        UpdateComment = ''    
        if r in ChangedRecords_:
            logger.info("updating records for run = %s"%r)
            UpdateComment = 'Updated in snapshot'
    
        goodStart = RunInfo_[r]['tStart']
        if RunInfo_[r]['good_tstart'] != "NULL" : goodStart = RunInfo_[r]['good_tstart']
        goodStart_frac = RunInfo_[r]['tStart_frac']
        if RunInfo_[r]['good_tstart_frac'] != "NULL" : goodStart_frac = RunInfo_[r]['good_tstart_frac']
        
        goodStop = RunInfo_[r]['tStop']
        if RunInfo_[r]['good_tstop'] != "NULL"  : goodStop = RunInfo_[r]['good_tstop']
        goodStop_frac = RunInfo_[r]['tStop_frac']
        if RunInfo_[r]['good_tstop_frac'] != "NULL"  : goodStop_frac = RunInfo_[r]['good_tstop_frac']
        # Check PFFilt files if there are empty and/or have no reading permission
        fileChkRlt = libs.checks.pffilt_size_and_permission(r, RunInfo_[r]['tStart'].year, RunInfo_[r]['tStart'].month, RunInfo_[r]['tStart'].day, logger, False)
        if len(fileChkRlt['empty']) + len(fileChkRlt['permission']) + len(fileChkRlt['emptyAndPermission']) > 0:
            logger.warning("Run %s has issues with PFFilt files" % r)
            logger.warning('  Empty files w/o reading permission:')
    	for file in fileChkRlt['emptyAndPermission']:
    	    logger.warning('    ' + file)
    
            logger.warning('  Empty files w/ reading permission:')
            for file in fileChkRlt['empty']:  
                logger.warning('    ' + file )
    
            logger.warning('  Not empty files w/o reading permission:')
            for file in fileChkRlt['permission']:
                logger.warning('    ' + file)
    
        # insert new runs from live in grl_snapshot_info
        if not dryrun: dbs4_.execute( """insert into i3filter.grl_snapshot_info
                            (ss_ref,run_id,snapshot_id,good_i3,good_it,reason_i3,reason_it,
                            production_version,submitted,comments,good_tstart,good_tstart_frac,
                            good_tstop,good_tstop_frac)
                            values(%u,%u,%u,%u,%u,"%s","%s",%u,%u,"%s","%s",%s,"%s",%s)
                            """%(ss_ref,r,RunInfo_[r]['snapshot_id'],RunInfo_[r]['good_i3'],RunInfo_[r]['good_it'],
                            reason_i3,reason_it,CurrentProductionVersion,0,UpdateComment,
                            goodStart,goodStart_frac,goodStop,goodStop_frac))
        
        ss_ref+=1
    return 0


if __name__ == "__main__":
    config = libs.config.get_config()

    parser = get_defaultparser(__doc__,dryrun=True)

    parser.add_argument('--check', help="Only check for updates. Do nothing else",dest="check",action="store_true",default=False)  

    args = parser.parse_args()
    LOGFILE=os.path.join(get_logdir(sublogpath = 'PreProcessing'), 'GetRunInfo_')
    logger = get_logger(args.loglevel,LOGFILE)
    main(logger = logger, dryrun=args.dryrun, check = args.check, config = config)    


