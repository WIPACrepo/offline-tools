#!/usr/bin/env python

import os
import tarfile
import subprocess

from glob import glob

from libs.argparser import get_defaultparser
from libs.logger import get_logger
from libs.config import get_config
from libs.databaseconnection import DatabaseConnection
from libs.utils import Counter
from libs.process import Lock
from libs.runs import Run
from libs.path import get_tmpdir, get_env_python_path, get_logdir
from libs.email import send_email
from libs.files import File
from libs.cron import cron_finished

def find_previous_run(run, db, logger, dryrun):
    sql = run.format('SELECT * FROM i3filter.runs WHERE run_id < {run_id} AND (good_it OR good_i3) ORDER BY run_id DESC, snapshot_id DESC, production_version DESC LIMIT 1')
    logger.debug('SQL: {}'.format(sql))

    data = db.fetchall(sql)
    if not len(data):
        return None

    if len(data) != 1:
        raise RuntimeError('Expected exactly one row')

    config = get_config(logger)
    if run.get_season() != config.get_season_by_run(data[0]['run_id']):
        logger.debug('Season for run {run_id}: {season}'.format(season = config.get_season_by_run(data[0]['run_id']), **data[0]))
        logger.debug(run.format('Season for run {run_id}: {season}'))

        return None

    return Run(data[0]['run_id'], logger, dryrun = dryrun)

def main(run_ids, args, config, db, logger):
    counter = Counter(['handled', 'skipped', 'error', 'validated'])

    logger.info('Start checking {0} runs'.format(len(run_ids)))

    # Create Run objects and filter bad runs
    runs = []
    for run_id in sorted(run_ids):
        try:
            r = Run(run_id, logger, dryrun = args.dryrun)
            r.load()

            if r.is_good_run() or (r.is_test_run() and not r.is_failed_run()):
                runs.append(r)
        except LoadRunDataException:
            logger.warning('Skipping run {0} since there are no DB entries'.format(run_id))
            counter.count('skipped')

    # Check runs
    for run in runs:
        counter.count('handled')

        # Find previous/template GCD file
        template_run = find_previous_run(run, db, logger, args.dryrun)

        if template_run is None:
            logger.warning(run.format('Could not find template run for run {run_id}. Skip this run.'))
            counter.count('skipped')
            continue

        template_gcd = template_run.get_gcd_file()

        # Find current GCD file
        current_gcd = run.get_gcd_file()
        logger.debug('Current GCD file path: {0}'.format(current_gcd))
        logger.debug('Template GCD file path: {0}'.format(template_gcd))

        if current_gcd is None:
            logger.warning(run.format('Run {run_id} has no north GCD file in the datawarehouse. Skip this run.'))
            counter.count('skipped')
            continue

        if template_gcd is None:
            logger.warning(template_run.format('Run {run_id} (template run) has no north GCD file in the datawarehouse. Skip this run.'))
            counter.count('skipped')
            continue

        run_log_file = run.format(config.get('TemplateGCDChecks', 'RunLogFile'))

        with open (run_log_file, 'w') as run_log:
            return_code = subprocess.call([
                get_env_python_path(),
                config.get('GCDGeneration', 'GCDCompareTool'),
                template_gcd.path,
                current_gcd.path,
                '--ignore-start-end-times'
                ], stdout = run_log, stderr = run_log)

        logger.debug('GCD Diff return code: {0}'.format(return_code))

        sql = run.format("""
            UPDATE i3filter.runs
            SET gcd_template_validation = {return_code}
            WHERE run_id = {run_id} AND
                snapshot_id = {snapshot_id} AND
                production_version = {production_version}
        """, return_code = return_code)

        logger.debug(sql)

        if not args.dryrun:
            db.execute(sql)

        if return_code:
            email_content = """
                *** This is an automated message generated by the *** <br>
                ***           Template Checking System            *** <br><br>

                Template Check for<br>
                Run: <b>{run_id}</b><br>
                returned a non-zero value: <b>{return_code}</b> <br>
                The files compared are:<br>
                Current File: {current_gcd}<br>
                Template File: {template_gcd}<br>
                <b>GCD Diff output:</b><br>
                <pre>{gcddiff}</pre>
                """

            with open(run_log_file, 'r') as f:
                gcddiff = f.read()

            email_content = run.format(email_content, return_code = return_code, current_gcd = current_gcd, template_gcd = template_gcd, gcddiff = gcddiff)

            send_email(
                config.get_var_list('TemplateGCDChecks', 'NotificationReceiver'),
                run.format('Template change for Run {run_id}'),
                email_content,
                logger,
                args.dryrun
            )

            logger.info(run.format("Check failed for run {run_id}"))
            counter.count('error')
        else:
            logger.info(run.format("Run {run_id} passed check"))
            counter.count('validated')

    logger.info('Template GCD validation complete: {0}'.format(counter.get_summary()))
    return counter

if __name__ == '__main__':
    parser = get_defaultparser(__doc__, dryrun = True)
    parser.add_argument("-s", "--startrun", type = int, required = False, default = None, help = "Start checking from this run")
    parser.add_argument("-e", "--endrun", type = int, required = False, default= None, help = "End checking at this run")
    parser.add_argument("--runs", type = int, nargs = '*', required = False, help = "Checking specific runs. Can be mixed with -s and -e")
    parser.add_argument("--recheck-failed", action = "store_true", default = False, help = "Re-check all failed files")
    parser.add_argument("--cron", action = "store_true", default = False, help = "Use this option if you call this script via a cron")
    args = parser.parse_args()

    logfile = os.path.join(get_logdir(sublogpath = 'TemplateGCDChecks'), 'TemplateGCDChecks_')

    if args.logfile is not None:
        logfile = args.logfile

    logger = get_logger(args.loglevel, logfile)   

    config = get_config(logger)

    db = DatabaseConnection.get_connection('filter-db', logger)

    # Check arguments
    runs = args.runs

    if runs is None:
        runs = []

    if args.startrun is not None:
        if args.endrun is None:
            logger.critical('If --startrun, -s has been set, also the --endrun, -e needs to be set.')
            exit(1)

        runs.extend(range(args.startrun, args.endrun + 1))
    elif args.endrun is not None:
        logger.critical('If --endrun, -e has been set, also the --startrun, -s needs to be set.')
        exit(1)

    if not len(runs):
        # Get all runs of current season:
        season = config.getint('DEFAULT', 'Season')
        info = config.get_seasons_info()

        first_run = info[season]['first']
        test_runs = info[season]['test']
        last_run = 99999999
        exclude_next_testruns = []

        if season + 1 in info:
            if info[season + 1]['first'] > -1:
                last_run = info[season + 1]['first'] - 1

            exclude_next_testruns = info[season + 1]['test']

        if args.recheck_failed:
            recheck = 'OR gcd_template_validation > 0'
        else:
            recheck = ''

        sql = """
            SELECT run_id FROM i3filter.runs
            WHERE (run_id BETWEEN {first_run} AND {last_run} OR run_id IN ({test_runs})) AND
                run_id NOT IN ({exclude_next_testruns}) AND
                (gcd_template_validation IS NULL {recheck}) AND
                gcd_generated AND gcd_bad_doms_validated
        """.format(
            recheck = recheck,
            first_run = first_run,
            last_run = last_run,
            test_runs = ','.join([str(r) for r in test_runs + ['-1']]),
            exclude_next_testruns = ','.join([str(r) for r in exclude_next_testruns + ['-1']])
        )

        logger.debug('SQL: {0}'.format(sql))
        data = db.fetchall(sql)

        for row in data:
            runs.append(int(row['run_id']))

        logger.warning("No runs were explecitely specified. Will check any not-checked run of season {season}.".format(season = season))
   
    lock = Lock(os.path.basename(__file__), logger)
    lock.lock()

    counter = main(runs, args, config, db, logger)

    if args.cron:
        cron_finished(os.path.basename(__file__), counter, logger, args.dryrun)

    lock.unlock()

    logger.info('Done')

