#!/usr/bin/env python
"""
Compare the GCD Files created in the North to those created
at the Pole and transferred to the North
"""

import os
import tarfiles
import subprocess

from glob import glob

from libs.argparser import get_defaultparser
from libs.logger import get_logger
from libs.config import get_config
from libs.databaseconnection import DatabaseConnection
from libs.utils import Counter
from libs.process import Lock
from libs.runs import Run
from libs.path import get_tmpdir, get_env_python_path
from libs.email import send_email

def main(runs, args, config, logger):
    counter = Counter(['handled', 'skipped', 'error', 'validated'])

    logger.info('Start checking {0} runs'.format(len(runs)))

    # Check runs
    for run_id in runs:
        run = Run(run_id, logger, dryrun = args.dryrun)

        sps_gcd = run.get_sps_gcd_file()
        logger.debug('SPS GCD file path: {0}'.format(sps_gcd))

        if sps_gcd is None:
            logger.warning(run.format('Run {run_id} has no SPS GCD file in the datawarehouse. Skip this run.'))
            counter.count('skipped')
            continue

        north_gcd = run.get_gcd_file()
        logger.debug('North GCD file path: {0}'.format(north_gcd))

        if north_gcd is None:
            logger.warning(run.format('Run {run_id} has no north GCD file in the datawarehouse. Skip this run.'))
            counter.count('skipped')
            continue

        # Untar/gunzip SPS gcd file
        with tarfile.open(sps_gcd, 'r:gz') as tf:
            tf.extractall(path = get_tmpdir())

        # In the .tar.gz file is another tar file that is similar named
        tartar = os.path.join(get_tmpdir(), os.path.basename(sps_gcd.replace('.i3.tar.gz', '.i3.dat.tar')))

        logger.debug('Untar: {0}'.format(tartar))

        with tarfile.open(tartar, 'r') as tf:
            tf.extractall(path = get_tmpdir())

        # The actual GCD file name iiiiiiiiiis:
        sps_gcd = os.path.join(get_tmpdir(), os.path.basename(sps_gcd).replace('.i3.tar.gz', '.i3.gz'))

        # Check if this file really exists:
        if not os.path.isfile(sps_gcd):
            logger.error('Did not find finlly the GCD file in the tar file. Expected path: {0}'.format(sps_gcd))
            counter.count('error')
            continue

        run_log_file = run.format(config.get('PoleGCDChecks', 'RunLogFile'))

        with open (run_log_file, 'w') as run_log:
            return_code = subprocess.call([
                get_env_python_path(),
                config.get('GCDGeneration', 'GCDCompareTool'),
                sps_gcd,
                north_gcd
                ], stdout = run_log, stderr = run_log)

        sql = run.format("""
            UPDATE i3filter.runs
            SET gcd_pole_validation = {return_code}
            WHERE run_id = {run_id} AND
                snapshot_id = {snapshot_id} AND
                production_version = {production_version}
        """, return_code = return_code)

        logger.debug(sql)

        if not args.dryrun:
            db.execute(sql)
                
        if return_code:
            email_content += """
                *** This is an automated message generated by the *** <br>
                ***        Pole/North GCD Comparison System   *** <br><br>
  
                GCD Pole/North Comparison Check for<br>
                Run:<b>%s</b><br>
                returned a non-zero value: <b>%s</b> <br>
                The files compared are: <br>
                northFile: %s <br>
                poleFile: %s
                """%(runNum,RV,northFile,f)

                send_email(
                    config.get_var_list('PoleGCDChecks', 'NotificationReceiver'),
                    run.format('Pole/North GCD check for Run {run_id}'),
                    email_content,
                    logger,
                    args.dryrun
                )

            logger.info(run.format("Check failed for run {run_id}"))
            counter.count('error')
        else:
            logger.info(run.format("Run {run_id} passed check"))
            counter.count('validated')

        # Clean up
        files = glob(os.path.join(get_tmpdir(), os.path.basename(os.path.splitext(sps_gcd)[0]) + '*'))

        for f in files:
            logger.debug('Delete: {0}'.format(f))

            if not args.dryrun:
                os.remove(f)

    logger.info('Pole GCD validation complete: {0}'.format(counter.get_summary()))

if __name__ == '__main__':
    parser = get_defaultparser(__doc__, dryrun = True)
    parser.add_argument("-s", "--startrun", type = int, required = False, default = None, help = "Start checking from this run")
    parser.add_argument("-e", "--endrun", type = int, required = False, default= None, help = "End checking at this run")
    parser.add_argument("--runs", type = int, nargs = '*', required = False, help = "Checking specific runs. Can be mixed with -s and -e")
    args = parser.parse_args()

    logfile = os.path.join(get_logdir(sublogpath = 'PoleGCDChecks'), 'PoleGCDChecks_')

    if args.logfile is not None:
        logfile = args.logfile

    logger = get_logger(args.loglevel, logfile)   

    config = get_config(logger)

    db = DatabaseConnection.get_connection('filter-db', logger)

    # Check arguments
    runs = args.runs

    if runs is None:
        runs = []

    if args.startrun is not None:
        if args.endrun is None:
            logger.critical('If --startrun, -s has been set, also the --endrun, -e needs to be set.')
            exit(1)

        runs.extend(range(args.startrun, args.endrun + 1))
    elif args.endrun is not None:
        logger.critical('If --endrun, -e has been set, also the --startrun, -s needs to be set.')
        exit(1)

    if not len(runs):
        # Get all runs of current season:
        season = config.getint("DEFAULT', 'Season')
        info = config.get_seasons_info()

        first_run = info[season]['first']
        test_runs = info[season]['test']
        last_run = 99999999

        if season + 1 in info:
            if info[season + 1]['first'] > -1:
                last_run = info[season + 1]['first'] - 1

            exclude_next_testruns = info[season + 1]['test']

        sql = """
            SELECT run_id FROM i3filter.runs
            WHERE (run_id BETWEEN {first_run} AND {last_run} OR run_id IN ({test_runs})) AND
                run_id NOT IN ({exclude_next_testruns}) AND
                (gcd_pole_validation IS NULL OR gcd_pole_validation > 0) AND
                gcd_generated AND gcd_bad_doms_validated
        """.format(
            first_run = first_run,
            last_run = last_run,
            test_runs = ','.join([str(r) for r in test_runs + ['-1']]),
            exclude_next_testruns = ','.join([str(r) for r in exclude_next_testruns + ['-1']])
        )

        logger.debug('SQL: {0}'.format(sql))
        data = db.fetchall(sql)

        for row in data:
            runs.append(int(row['run_id']))

        logger.warning("No runs were explecitely specified. Will check any not-checked run of season {season}.".format(season = season))
   
    lock = Lock(os.path.basename(__file__), logger)
    lock.lock()

    main(runs, args, config, logger)

    lock.unlock()

    logger.info('Done')

